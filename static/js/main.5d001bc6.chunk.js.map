{"version":3,"sources":["constants.js","utils.js","reducer.js","components/battlefield/battlefield.jsx","components/app/app.jsx","index.js"],"names":["CellSymbols","GameTurns","GameStages","extend","a","b","Object","assign","getCellCoords","cellNumber","boardSize","x","y","Math","floor","initialState","cells","Array","fill","map","symbol","isVictorious","turn","gameStage","ActionType","ActionCreator","type","payload","stage","makeCellTemplate","cellName","id","onCellClick","key","onClick","className","width","height","xlinkHref","Battlefield","cell","i","newCellClick","connect","state","dispatch","activeCell","currentCells","currentTurn","newCells","activeCellCoords","filterBy","checkCoords","index","cellCoords","filterBySymbol","currentRow","filter","cellX","cellY","currentColumn","straightDiagonal","reverseDiagonal","length","forEach","isVictoryFound","Error","toggleGameTurn","gameTurn","mapToWinStage","onRestartButtonClick","statusText","String","fromCodePoint","store","createStore","action","window","__REDUX_DEVTOOLS_EXTENSION__","f","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5d001bc6.chunk.js","sourcesContent":["export const BOARDSIZE = 3;\r\n\r\nexport const CellSymbols = {\r\n  EMPTY: `EMPTY`,\r\n  CROSS: `CROSS`,\r\n  NOUGHT: `NOUGHT`,\r\n};\r\n\r\nexport const GameTurns = {\r\n  CROSSES: `Crosses`,\r\n  NOUGHTS: `Noughts`,\r\n  NOBODYS: `Nobody's`,\r\n};\r\n\r\nexport const GameStages = {\r\n  PLAYING: `PLAYING`,\r\n  CROSSES_WINS: `CROSSES_WINS`,\r\n  NOUGHTS_WINS: `NOUGHTS_WINS`,\r\n  DRAW: `DRAW`,\r\n};\r\n","import {GameStages, GameTurns} from \"./constants\";\r\n\r\nexport const extend = (a, b) => {\r\n  return Object.assign({}, a, b);\r\n};\r\n\r\nexport const mapToWinStage = (gameTurn) => {\r\n  switch (gameTurn) {\r\n    case GameTurns.CROSSES:\r\n      return GameStages.CROSSES_WINS;\r\n    case GameTurns.NOUGHTS:\r\n      return GameStages.NOUGHTS_WINS;\r\n    default:\r\n      throw new Error(`Invalid turn type: ${gameTurn}`);\r\n  }\r\n};\r\n\r\nexport const toggleGameTurn = (currentTurn) => {\r\n  switch (currentTurn) {\r\n    case GameTurns.CROSSES:\r\n      return GameTurns.NOUGHTS;\r\n    case GameTurns.NOUGHTS:\r\n      return GameTurns.CROSSES;\r\n    case GameTurns.NOBODYS:\r\n      return GameTurns.NOBODYS;\r\n    default:\r\n      throw new Error(`Unsupported turn type: ${currentTurn}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Восстановление координат ячейки по ее номеру в массиве\r\n * @param cellNumber - порядковый номер ячейки в массиве\r\n * @param boardSize - размер игрового поля\r\n * @returns {{x: number, y: number}} - координаты ячейки\r\n */\r\nexport const getCellCoords = (cellNumber, boardSize) => {\r\n  return {\r\n    x: cellNumber % boardSize,\r\n    y: Math.floor(cellNumber / boardSize),\r\n  };\r\n};\r\n","import {CellSymbols, GameTurns, GameStages} from \"./constants\";\r\nimport {extend} from \"./utils\";\r\n\r\nconst initialState = {\r\n  cells: Array(9).fill(null).map(() => ({symbol: CellSymbols.EMPTY, isVictorious: false})),\r\n  turn: GameTurns.CROSSES,\r\n  gameStage: GameStages.PLAYING,\r\n};\r\n\r\nconst ActionType = {\r\n  SET_CELLS: `SET_CELLS`,\r\n  SET_TURN: `SET_TURN`,\r\n  SET_GAME_STAGE: `SET_GAME_STAGE`,\r\n  RESTART_GAME: `RESTART_GAME`,\r\n};\r\n\r\nconst ActionCreator = {\r\n  setCells: (cells) => ({\r\n    type: ActionType.SET_CELLS,\r\n    payload: cells,\r\n  }),\r\n  setTurn: (turn) => ({\r\n    type: ActionType.SET_TURN,\r\n    payload: turn,\r\n  }),\r\n  setGameStage: (stage) => ({\r\n    type: ActionType.SET_GAME_STAGE,\r\n    payload: stage,\r\n  }),\r\n  restartGame: () => ({\r\n    type: ActionType.RESTART_GAME,\r\n    payload: null,\r\n  }),\r\n};\r\n\r\nconst reducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ActionType.SET_CELLS:\r\n      return extend(state, {\r\n        cells: action.payload,\r\n      });\r\n\r\n    case ActionType.SET_TURN:\r\n      return extend(state, {\r\n        turn: action.payload,\r\n      });\r\n\r\n    case ActionType.SET_GAME_STAGE:\r\n      return extend(state, {\r\n        gameStage: action.payload,\r\n      });\r\n\r\n    case ActionType.RESTART_GAME:\r\n      return initialState;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\n\r\nexport {reducer, ActionType, ActionCreator};\r\n","import React from \"react\";\r\nimport {CellSymbols} from \"../../constants\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nconst makeCellTemplate = (cellName, isVictorious, id, onCellClick) => {\r\n  return (\r\n    <div\r\n      key={id}\r\n      onClick={onCellClick}\r\n      className={`battlefield__cell battlefield__cell--${cellName} ${isVictorious ? `battlefield__cell--victory` : ``}`}>\r\n      <svg width=\"50\" height=\"50\">\r\n        <use xlinkHref={`#${cellName}`}/>\r\n      </svg>\r\n    </div>\r\n  );\r\n};\r\n\r\nconst Battlefield = ({cells, turn, onCellClick}) => {\r\n\r\n  return (\r\n      <div className=\"game-screen__battlefield battlefield\">\r\n        {\r\n          cells.map((cell, i) => {\r\n            const newCellClick = () => {onCellClick(i, cells, turn)};\r\n            switch (cell.symbol) {\r\n              case CellSymbols.CROSS:\r\n                return makeCellTemplate(`cross`, cell.isVictorious, i, newCellClick);\r\n              case CellSymbols.NOUGHT:\r\n                return makeCellTemplate(`nought`, cell.isVictorious, i, newCellClick);\r\n              case CellSymbols.EMPTY:\r\n              default:\r\n                return <div key={i} onClick={newCellClick} className=\"battlefield__cell\"/>;\r\n            }\r\n          })\r\n        }\r\n      </div>\r\n  );\r\n};\r\n\r\nBattlefield.propTypes = {\r\n  cells: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      symbol: PropTypes.string.isRequired,\r\n      isVictorious: PropTypes.bool.isRequired\r\n    })),\r\n  turn: PropTypes.string.isRequired,\r\n  onCellClick: PropTypes.func.isRequired,\r\n};\r\n\r\nexport default Battlefield;\r\n","import React from 'react';\nimport PropTypes from \"prop-types\";\nimport {connect} from \"react-redux\";\nimport {ActionCreator} from \"../../reducer\";\nimport './app.css';\nimport Battlefield from '../../components/battlefield/battlefield.jsx';\nimport {BOARDSIZE, CellSymbols, GameStages, GameTurns} from \"../../constants\";\nimport {getCellCoords, mapToWinStage, toggleGameTurn} from \"../../utils\";\n\nconst App = ({cells, turn, gameStage, onCellClick, onRestartButtonClick}) => {\n  let statusText = `Let's play!`;\n  switch (gameStage) {\n    case GameStages.PLAYING:\n      statusText = `Waiting for ${turn}...`;\n      break;\n    case GameStages.NOUGHTS_WINS:\n      statusText = `${GameTurns.NOUGHTS} wins! ${String.fromCodePoint(0x1F44F)}`;\n      break;\n    case GameStages.CROSSES_WINS:\n      statusText = `${GameTurns.CROSSES} wins! ${String.fromCodePoint(0x1F44F)}`;\n      break;\n    case GameStages.DRAW:\n      statusText = `It's a draw, so friendship won! ${String.fromCodePoint(0x1F44A)}`;\n      break;\n    default:\n      break;\n  }\n\n  return (\n    <section className=\"game-screen\">\n      <div className=\"game-screen__status-bar\">{statusText}</div>\n      <Battlefield cells={cells} turn={turn} onCellClick={onCellClick}/>\n      <div className=\"game-screen__footer\">\n        <button onClick={onRestartButtonClick} className=\"button\"><span>Restart game</span></button>\n      </div>\n    </section>\n  );\n};\n\n/**\n * Поиск выигравшей линии и изменение свойства isVictorious ячеек\n * @param newCells - массив ячеек над которым проводятся проверки и в кототорый возможно добавится атрибут найденной линии\n * @param activeCell - номер измененной ячейки в массиве cells\n * @returns {boolean} - найдена ли победная линия (строка, столбец или диагональ)\n */\nconst isVictoryFound = (newCells, activeCell) => {\n  const activeCellCoords = getCellCoords(activeCell, BOARDSIZE);\n\n  const filterBy = (checkCoords) => {\n    return function (cell, index) {\n      const cellCoords = getCellCoords(index, BOARDSIZE);\n      return checkCoords(cellCoords.x, cellCoords.y);\n    }\n  };\n\n  const filterBySymbol = (cell) => {\n    return cell.symbol === newCells[activeCell].symbol;\n  };\n\n  // Множественный фильтр по массиву ячеек - не самый производительный вариант, зато лаконичный и наглядный\n  const currentRow = newCells.filter(filterBy((cellX, cellY) => cellY === activeCellCoords.y));\n  const currentColumn = newCells.filter(filterBy((cellX) => cellX === activeCellCoords.x));\n  const straightDiagonal = newCells.filter(filterBy((cellX, cellY) => cellX === cellY));\n  const reverseDiagonal = newCells.filter(filterBy((cellX, cellY) =>  cellX === BOARDSIZE - cellY - 1));\n\n  switch (true) {\n    case currentRow.filter(filterBySymbol).length === BOARDSIZE:\n      currentRow.forEach((cell) => cell.isVictorious = true);\n      return true;\n    case currentColumn.filter(filterBySymbol).length === BOARDSIZE:\n      currentColumn.forEach((cell) => cell.isVictorious = true);\n      return true;\n    case straightDiagonal.filter(filterBySymbol).length === BOARDSIZE:\n      straightDiagonal.forEach((cell) => cell.isVictorious = true);\n      return true;\n    case reverseDiagonal.filter(filterBySymbol).length === BOARDSIZE:\n      reverseDiagonal.forEach((cell) => cell.isVictorious = true);\n      return true;\n    default:\n      return false;\n  }\n};\n\nApp.propTypes = {\n  cells: PropTypes.arrayOf(\n    PropTypes.shape({\n      symbol: PropTypes.string.isRequired,\n      isVictorious: PropTypes.bool.isRequired\n    })),\n  turn: PropTypes.string.isRequired,\n  gameStage: PropTypes.string.isRequired,\n  onCellClick: PropTypes.func.isRequired,\n  onRestartButtonClick: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = (state) => ({\n  cells: state.cells,\n  turn: state.turn,\n  gameStage: state.gameStage,\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n  onCellClick(activeCell, currentCells, currentTurn) {\n    if (currentCells[activeCell].symbol !== CellSymbols.EMPTY) {\n      return;\n    }\n\n    const newCells = currentCells.map(cell => ({...cell}));\n\n    if (currentTurn === GameTurns.CROSSES) {\n      newCells[activeCell].symbol = CellSymbols.CROSS;\n    } else if (currentTurn === GameTurns.NOUGHTS) {\n      newCells[activeCell].symbol = CellSymbols.NOUGHT;\n    } else {\n      return;\n    }\n\n    dispatch(ActionCreator.setCells(newCells));\n\n    if (isVictoryFound(newCells, activeCell)) {\n      dispatch(ActionCreator.setGameStage(mapToWinStage(currentTurn)));\n      dispatch(ActionCreator.setTurn(GameTurns.NOBODYS));\n    } else if (newCells.filter(cell => cell.symbol !== CellSymbols.EMPTY).length === newCells.length) {\n      dispatch(ActionCreator.setGameStage(GameStages.DRAW));\n      dispatch(ActionCreator.setTurn(GameTurns.NOBODYS));\n    } else {\n      dispatch(ActionCreator.setTurn(toggleGameTurn(currentTurn)));\n    }\n  },\n  onRestartButtonClick() {\n    dispatch(ActionCreator.restartGame());\n  }\n});\n\nexport {App};\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/app/app.jsx';\nimport {createStore} from \"redux\";\nimport {Provider} from \"react-redux\";\nimport {reducer} from './reducer';\n\nconst store = createStore(\n  reducer,\n  window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f\n);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}